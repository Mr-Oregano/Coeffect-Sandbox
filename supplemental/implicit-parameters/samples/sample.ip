
# We use "{ ... }" to encode the latent coeffects of function types
# In the case of implicit parameters, our latent coeffects will be a 
# comma-separated list of implicit bindings that will be required on application
# 
# Ideally we would have some form of type inference, but for now, programmers
# will also explicitly declare implicit parameters optionally after each
# parameter binding (indicating that the latent coeffects become relevant when
# applying the parameter in questioN)

# "foo" should be typed as: int { ?x: int } -> int
# it has an implicit parameter effective when applying the first and only argument
fun foo (y: int) { ?x: int }: int = ?x + y

# NOTE: The following cases are relevant for type inference. 
# They do not apply for when the programmer explicitly states the implicit parameters

# Consider the case for currying functions:
#   if the function requires any implicit parameters, the latent
#   effect will be encoded in the last arrow
#
#   we could consider adding a facility for the user to explicitly
#   indicate at what point the latent coeffect should apply
#
# "bar" should be typed as: int -> int { ?x: int } -> int
#
fun bar (y: int) (z: int) { ?x: int }: int = ?x + y + z

# Consider the case for nested functions, this is more or less the same
# as the previous case. If we bind an implicit parameter in the outer function
# then we will force the latent requirement to happen earlier in the type.
#
# The question becomes: should the returned function type still require the 
# latent coeffects?
#
# "baz" should be typed as: int { ?x: int } -> int -> int
#                                           OR?
#                           int { ?x: int } -> int { ?x: int } -> int
# 
# TODO: Currently, there are no lambda functions, should consider adding them
#
# fun baz (y: int) = let x = ?x in 
#    \(z: int) {?x: int} = x * ?x * y * z

# "new1" should be typed as int { ?x: int } -> int 
# "new2" should be typed as int -> int
#                               OR?
#                           int { ?x: int } -> int
#
val new1 = bar 420
val new2 = letdyn ?x = 69 in bar 420

# What if we don't use an implicit binding?
#
# "ign1" should be typed as: int -> int { ?x: int } -> int
# "ign2" should be typed as: int -> int -> int
#
# fun ign1 (y: int) (z: int): int = let x = ?x in x + y + z
# fun ign2 (y: int) (z: int): int = let w = ?x in y + z

# An interesting consideration for the previous could be a map function that expects
# a mapping function with a latent coeffect providing an index as an implicit parameter
#
# However, the user should not be forced to use an implicit parameter in their 
# mapping function if they do not wish to do so.
#
# We have sub-typing rules for coeffects that allow us to relax the type system.
# An expression requiring no implicit parameter is a subtype of an expression 
# requiring 1 or more implicit parameters.
#
# fun map (f: int {?idx: int} -> int) (l: int list): int list = 
#     fun _aux (i: int) (l: int list): int list = 
#         match l with
#         | Nil -> Nil
#         | Cons (x, xs) -> 
#             let x' = (letdyn ?idx = i in f x) in
#             Cons (x', _aux (i + 1) xs)
# 
#     _aux 0 l            
#
# val res = (letdyn ?x = 6 in map (baz 7) [1, 2, 3, 4, 5])

;

letdyn ?x = 6 in foo 7