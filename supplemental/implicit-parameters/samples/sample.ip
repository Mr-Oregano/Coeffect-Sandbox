
# "foo" will be typed as: int { ?x: int } -> int
fun foo (y: int) { ?x: int }
   : int { ?x: int } -> int 
   = ?x + y

# "bar" will be typed as: int -> int { ?x: int } -> int
fun bar (y: int) (z: int) { ?x: int }
   : int -> int { ?x: int } -> int 
   = ?x + y + z

# "new1" will be typed as int { ?x: int } -> int 
val new1 
   : int { ?x: int } -> int
   = bar 420

# "baz" will be typed as: int { ?x: int } -> int -> int
fun baz (y: int) {?x: int}
   : int { ?x: int } -> int -> int
   = \(z: int) -> ?x + y + z

# "new2" will be typed as: int -> int
val new2 
   : int -> int
   = letdyn ?x = 1 in baz 1

# Consider the case for when we want full dynamic binding:
#   Here the latent coeffect applies for every nested call
#
# "bam" will be typed as: int { ?x: int } -> int { ?x: int } -> int
# 
fun bam (y: int) { ?x: int }
   : int { ?x: int } -> int { ?x: int } -> int
   = (\(x: int) -> \(z: int) { ?x: int } -> x + ?x + y + z) ?x

# "new3" will be typed as: int { ?x: int } -> int
val new3
   : int { ?x: int } -> int
   = letdyn ?x = 1 in bam 1

;

# letdyn ?x = 69 in foo 420 # Outputs: 489
# letdyn ?x = 69 in new1 420 # Outputs: 909
# new2 1 # Outputs: 3
# letdyn ?x = 0 in new3 1 # Outputs: 3
# new3 1 # Type error: implicit not bound!
# foo 7 # Type error: implicit not bound!
# new1 7 # Type error: implicit not bound!